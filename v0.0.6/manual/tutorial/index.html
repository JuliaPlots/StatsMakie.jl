<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · StatsMakie</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StatsMakie</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Grouping-data-by-discrete-variables-1">Grouping data by discrete variables</a></li><li><a class="toctext" href="#Styling-data-with-continuous-variables-1">Styling data with continuous variables</a></li><li><a class="toctext" href="#Split-apply-combine-strategy-with-a-plot-1">Split-apply-combine strategy with a plot</a></li><li><a class="toctext" href="#What-if-I-have-data-instead?-1">What if I have data instead?</a></li><li><a class="toctext" href="#Wide-data-1">Wide data</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/JuliaPlots/StatsMakie.jl/blob/master/docs/src/manual/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><p>This tutorial shows how to create data visualizations using the StatsMakie grouping and styling APIs as well as the StatsMakie statistical recipes.</p><h2><a class="nav-anchor" id="Grouping-data-by-discrete-variables-1" href="#Grouping-data-by-discrete-variables-1">Grouping data by discrete variables</a></h2><p>The first feature that StatsMakie adds to Makie is the ability to group data by some discrete variables and use those variables to style the result. Let&#39;s first create some vectors to play with:</p><pre><code class="language-julia">N = 1000
a = rand(1:2, N) # a discrete variable
b = rand(1:2, N) # a discrete variable
x = randn(N) # a continuous variable
y = @. x * a + 0.8*randn() # a continuous variable
z = x .+ y # a continuous variable</code></pre><p>To see how <code>x</code> and <code>y</code> relate to each other, we could simply try (be warned: the first plot is quite slow, the following ones will be much faster):</p><pre><code class="language-julia">scatter(x, y, markersize = 0.2)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49149907-443b7980-f303-11e8-8836-96418f0f6b1f.png" alt="screenshot from 2018-11-28 11-46-19"/></p><p>It looks like there are two components in the data, and we can ask whether they come from different values of the <code>a</code> variable:</p><pre><code class="language-julia">scatter(Group(a), x, y, markersize = 0.2)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49149908-469dd380-f303-11e8-9f88-b541b8a3f06c.png" alt="screenshot from 2018-11-28 11-45-51"/></p><p><code>Group</code> will split the data by the discrete variable we provided and color according to that variable. Colors will cycle across a range of default values, but we can easily customize those:</p><pre><code class="language-julia">scatter(Group(a), x, y, color = [:black, :red], markersize = 0.2)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150007-8664bb00-f303-11e8-9c57-9e8af0fc401a.png" alt="screenshot from 2018-11-28 11-48-13"/></p><p>and of course we are not limited to grouping with colors: we can use the shape of the marker instead. <code>Group(a)</code> defaults to <code>Group(color = a)</code>, whereas <code>Group(marker = a)</code> with encode the information about variable <code>a</code> in the marker:</p><pre><code class="language-julia">scatter(Group(marker = a), x, y, markersize = 0.2)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150055-a2685c80-f303-11e8-908e-6487f968db8d.png" alt="screenshot from 2018-11-28 11-48-55"/></p><p>Grouping by many variables is also supported:</p><pre><code class="language-julia">scatter(Group(marker = a, color = b), x, y, markersize = 0.2)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150284-43571780-f304-11e8-9020-e976c1914efd.png" alt="screenshot from 2018-11-28 11-53-18"/></p><h2><a class="nav-anchor" id="Styling-data-with-continuous-variables-1" href="#Styling-data-with-continuous-variables-1">Styling data with continuous variables</a></h2><p>One of the advantage of using an inherently discrete quantity (like the shape of the marker) to encode a discrete variable is that we can use continuous attributes (e.g. color within a colorscale) for continuous variable. In this case, if we want to see how <code>a, x, y, z</code> interact, we could choose the marker according to <code>a</code> and style the color according to <code>z</code>:</p><pre><code class="language-julia">scatter(Group(marker = a), Style(color = z), x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150115-dba0cc80-f303-11e8-83f2-093c48335a0d.png" alt="screenshot from 2018-11-28 11-50-33"/></p><p>Just like with <code>Group</code>, we can <code>Style</code> any number of attributes in the same plot. <code>color</code> is probably the most common, <code>markersize</code> is another sensible option (especially if we are using <code>color</code> already for the grouping):</p><pre><code class="language-julia">scatter(Group(color = a), x, y, Style(markersize = z ./ 10))</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49215980-e9b52280-f3c1-11e8-8f6d-8b0962f2ba99.png" alt="screenshot from 2018-11-29 10-30-59"/></p><h2><a class="nav-anchor" id="Split-apply-combine-strategy-with-a-plot-1" href="#Split-apply-combine-strategy-with-a-plot-1">Split-apply-combine strategy with a plot</a></h2><p>StatsMakie also has the concept of a &quot;visualization&quot; function (which is somewhat different but inspired on Grammar of Graphics statistics). The idea is that any function whose return type is understood by StatsMakie (meaning, there is an appropriate visualization for it) can be passed as first argument and it will be applied to the following arguments as well.</p><p>A simple example is probably linear and non-linear regression.</p><h3><a class="nav-anchor" id="Linear-regression-1" href="#Linear-regression-1">Linear regression</a></h3><p>StatsMakie knows how to compute both a linear and non-linear fit of <code>y</code> as a function of <code>x</code>, via the &quot;analysis functions&quot; <code>linear</code> (linear regression) and <code>smooth</code> (local polynomial regression) respectively:</p><pre><code class="language-julia">using StatsMakie: linear, smooth

plot(linear, x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150406-b3fe3400-f304-11e8-84a0-8b402b66880c.png" alt="screenshot from 2018-11-28 11-56-38"/></p><p>That was anti-climatic! It is the linear prediction of <code>y</code> given <code>x</code>, but it&#39;s a bit of a sad plot! We can make it more colorful by splitting our data by <code>a</code>, and everything will work as above:</p><pre><code class="language-julia">plot(linear, Group(a), x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150498-fc1d5680-f304-11e8-809e-19113c99e345.png" alt="screenshot from 2018-11-28 11-58-32"/></p><p>And then we can plot it on top of the previous scatter plot, to make sure we got a good fit:</p><pre><code class="language-julia">scatter(Group(a), x, y, markersize = 0.2)
plot!(linear, Group(a), x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150576-38e94d80-f305-11e8-99e7-fedf0a2f114d.png" alt="screenshot from 2018-11-28 12-00-25"/></p><p>Here of course it makes sense to group both things by color, but for line plots we have other options like <code>linestyle</code>:</p><pre><code class="language-julia">plot(linear, Group(linestyle = a), x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150640-6cc47300-f305-11e8-8db7-d8a97e84218e.png" alt="screenshot from 2018-11-28 12-01-54"/></p><h3><a class="nav-anchor" id="A-non-linear-example-1" href="#A-non-linear-example-1">A non-linear example</a></h3><p>Using non-linear techniques here is not very interesting as linear techniques work quite well already, so let&#39;s change variables:</p><pre><code class="language-julia">N = 200
x = 10 .* rand(N)
a = rand(1:2, N)
y = sin.(x) .+ 0.5 .* rand(N) .+ cos.(x) .* a</code></pre><p>and then:</p><pre><code class="language-julia">scatter(Group(a), x, y)
plot!(smooth, Group(a), x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49150923-363b2800-f306-11e8-89d0-682aba6cb7b9.png" alt="screenshot from 2018-11-28 12-07-31"/></p><h3><a class="nav-anchor" id="Different-analyses-1" href="#Different-analyses-1">Different analyses</a></h3><p><code>linear</code> and <code>smooth</code> are two examples of possible analysis, but many more are possibles and it&#39;s easy to add new ones. If we were interested to the distributions of <code>x</code> and <code>y</code> for example we could do:</p><pre><code class="language-julia">plot(histogram, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49151084-cd07e480-f306-11e8-8399-6e0224ef3622.png" alt="screenshot from 2018-11-28 12-11-43"/></p><p>The default plot type is determined by the dimensionality of the input and the analysis: with two variables one would get a heatmap:</p><pre><code class="language-julia">plot(histogram, x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49151146-050f2780-f307-11e8-8a3d-99a4b9eb4349.png" alt="screenshot from 2018-11-28 12-13-16"/></p><p>This plots is reasonably customizable in that one can pass keywords arguments to the <code>histogram</code> analysis:</p><pre><code class="language-julia">plot(histogram(nbins = 30), x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49151196-2b34c780-f307-11e8-8a8f-a25fcc610b32.png" alt="screenshot from 2018-11-28 12-14-19"/></p><p>and change the default plot type to something else:</p><pre><code class="language-julia">wireframe(histogram(nbins = 30), x, y)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49151258-5ae3cf80-f307-11e8-81a3-711b36a1deb0.png" alt="screenshot from 2018-11-28 12-15-42"/></p><p>Of course heatmap is the saner choice, but why not abuse Makie 3D capabilities?</p><p>Other available analysis are <code>density</code> (to use kernel density estimation rather than binning) and <code>frequency</code> (to count occurrences of discrete variables).</p><h2><a class="nav-anchor" id="What-if-I-have-data-instead?-1" href="#What-if-I-have-data-instead?-1">What if I have data instead?</a></h2><p>If one has data instead, it is possible to signal StatsMakie that we are working from a DataFrame (or any table actually) and it will interpret symbols as columns:</p><pre><code class="language-julia">using DataFrames, RDatasets
iris = RDatasets.dataset(&quot;datasets&quot;, &quot;iris&quot;)
scatter(Data(iris), Group(:Species), :SepalLength, :SepalWidth)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49151656-7b605980-f308-11e8-8bb1-d5e745929c9d.png" alt="screenshot from 2018-11-28 12-23-41"/></p><p>And everything else works as usual:</p><pre><code class="language-julia"># use Position.stack to signal that you want bars stacked vertically rather than superimposed
plot(Position.stack, histogram, Data(iris), Group(:Species), :SepalLength)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49151854-05a8bd80-f309-11e8-9b9a-7dca7bf3cf6b.png" alt="screenshot from 2018-11-28 12-27-34"/></p><pre><code class="language-julia">wireframe(density(trim=true), Data(iris), Group(:Species), :SepalLength, :SepalWidth)</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49151783-d09c6b00-f308-11e8-8920-3bea731f28d8.png" alt="screenshot from 2018-11-28 12-26-08"/></p><h2><a class="nav-anchor" id="Wide-data-1" href="#Wide-data-1">Wide data</a></h2><p>Other than comparing the same column split by a categorical variable, one may also compare different columns put side by side (here in a <code>Tuple</code>, <code>(:PetalLength, :PetalWidth)</code>). The attribute that styles them has to be set to <code>bycolumn</code>. Here color will distinguish <code>:PetalLength</code> versus <code>:PetalWidth</code> whereas the marker will distinguish the species.</p><pre><code class="language-julia">scatter(
           Data(iris),
           Group(marker = :Species, color = bycolumn),
           :SepalLength, (:PetalLength, :PetalWidth)
       )</code></pre><p><img src="https://user-images.githubusercontent.com/6333339/49152507-f62a7400-f30a-11e8-876b-2df48e6d815a.png" alt="screenshot from 2018-11-28 12-41-30"/></p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
